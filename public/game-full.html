<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🥊 Boxing AI Ultimate - Full Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial Black', sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            text-align: center;
            position: relative;
        }
        
        canvas {
            border: 5px solid #ffd700;
            border-radius: 10px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.8);
        }
        
        /* MODE SELECTION */
        .game-mode-selector {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }
        
        .mode-content {
            background: linear-gradient(135deg, #1a1a2e, #2d0a0a);
            padding: 50px;
            border-radius: 20px;
            border: 5px solid #ffd700;
            max-width: 800px;
        }
        
        .mode-content h1 {
            font-size: 48px;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        }
        
        .mode-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .mode-card {
            background: linear-gradient(to bottom, #3498db, #2980b9);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #ffd700;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .mode-card:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(255,215,0,0.6);
        }
        
        .mode-card h2 {
            font-size: 32px;
            color: white;
            margin-bottom: 15px;
        }
        
        .mode-card p {
            color: #ffd700;
            font-size: 16px;
            line-height: 1.6;
        }
        
        .mode-card.survival {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
        }
        
        .mode-card.tournament {
            background: linear-gradient(to bottom, #f39c12, #e67e22);
        }
        
        .mode-card.training {
            background: linear-gradient(to bottom, #2ecc71, #27ae60);
        }
        
        .mode-card.timeattack {
            background: linear-gradient(to bottom, #9b59b6, #8e44ad);
        }
        
        /* PAUSE MENU */
        .pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2500;
        }
        
        .pause-content {
            background: linear-gradient(135deg, #1a1a2e, #2d0a0a);
            padding: 50px;
            border-radius: 20px;
            border: 5px solid #ffd700;
            text-align: center;
        }
        
        .pause-content h1 {
            font-size: 48px;
            color: #ffd700;
            margin-bottom: 30px;
        }
        
        .pause-content button {
            margin: 10px;
            padding: 20px 40px;
            font-size: 20px;
            background: linear-gradient(to right, #3498db, #2980b9);
            border: 3px solid #ffd700;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .pause-content button:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(255,215,0,0.6);
        }
        
        /* SOUND TOGGLE */
        .sound-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #ffd700;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 24px;
            z-index: 200;
            transition: all 0.3s;
        }
        
        .sound-toggle:hover {
            transform: scale(1.2);
            box-shadow: 0 5px 20px rgba(255,215,0,0.6);
        }
        
        /* TIMER DISPLAY */
        .timer-display {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 15px 30px;
            border-radius: 10px;
            border: 3px solid #ffd700;
            display: none;
        }
        
        .timer-display h2 {
            font-size: 48px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .timer-display.warning {
            animation: pulse 0.5s infinite;
            border-color: #ff0000;
        }
        
        .timer-display.warning h2 {
            color: #ff0000;
        }
        
        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
        }
        
        /* HUD */
        .hud {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            gap: 15px;
        }
        
        .player-stats {
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 10px;
            flex: 1;
            border: 3px solid;
        }
        
        .player1-stats { border-color: #4a90e2; }
        .player2-stats { border-color: #e74c3c; }
        
        .player-name {
            font-size: 18px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        
        .player1-stats .player-name { color: #4a90e2; }
        .player2-stats .player-name { color: #e74c3c; }
        
        .hp-bar, .energy-bar {
            width: 100%;
            height: 18px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        
        .hp-fill {
            height: 100%;
            transition: width 0.3s;
            background: linear-gradient(to right, #2ecc71, #27ae60);
        }
        
        .hp-fill.low { background: linear-gradient(to right, #f39c12, #e67e22); }
        .hp-fill.critical { background: linear-gradient(to right, #e74c3c, #c0392b); }
        
        .energy-fill {
            height: 100%;
            transition: width 0.3s;
            background: linear-gradient(to right, #3498db, #2980b9);
        }
        
        .stat-text {
            color: white;
            font-size: 11px;
            text-shadow: 1px 1px 2px black;
            margin-bottom: 5px;
        }
        
        .combo-display {
            color: #ffd700;
            font-size: 16px;
            min-height: 22px;
            font-weight: bold;
        }
        
        /* SKILLS */
        .skills-container {
            display: flex;
            gap: 5px;
            margin-top: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .skill-btn {
            background: linear-gradient(to bottom, #9b59b6, #8e44ad);
            border: 2px solid #ffd700;
            border-radius: 5px;
            padding: 6px 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            color: white;
            min-width: 35px;
        }
        
        .skill-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(255,215,0,0.6);
        }
        
        .skill-btn.cooldown {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(1);
        }
        
        .skill-cooldown-text {
            font-size: 10px;
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff6b6b;
        }
        
        /* MAP SELECTOR */
        .map-selector {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 8px 15px;
            border-radius: 8px;
            display: flex;
            gap: 8px;
            z-index: 100;
            border: 2px solid #ffd700;
        }
        
        .map-btn {
            background: linear-gradient(to bottom, #34495e, #2c3e50);
            border: 2px solid #95a5a6;
            border-radius: 5px;
            padding: 8px 12px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .map-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 5px 20px rgba(255,215,0,0.5);
        }
        
        .map-btn.active {
            background: linear-gradient(to bottom, #ffd700, #f39c12);
            border-color: #fff;
            transform: scale(1.1);
        }
        
        /* GAME INFO */
        .game-info {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 8px;
            color: #ffd700;
            font-size: 16px;
            border: 2px solid #ffd700;
            display: none;
        }
        
        /* CONTROLS HELP */
        .controls-help {
            color: #bbb;
            font-size: 10px;
            margin-top: 5px;
            line-height: 1.4;
        }
        
        /* GAME OVER */
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 50px 70px;
            border-radius: 20px;
            border: 5px solid #ffd700;
            display: none;
            z-index: 2000;
            text-align: center;
        }
        
        .game-over h1 {
            font-size: 56px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        }
        
        .winner1 { color: #4a90e2; }
        .winner2 { color: #e74c3c; }
        
        .game-over p {
            color: #ffd700;
            font-size: 20px;
            margin: 15px 0;
        }
        
        .game-over button {
            margin: 10px;
            padding: 20px 40px;
            font-size: 20px;
            background: linear-gradient(to right, #ffd700, #ffed4e);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .game-over button:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(255,215,0,0.6);
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
        }
    </style>
</head>
<body>
    <!-- GAME MODE SELECTOR -->
    <div class="game-mode-selector" id="gameModeSelector">
        <div class="mode-content">
            <h1>🥊 CHỌN CHẾ ĐỘ CHƠI 🥊</h1>
            <div class="mode-grid">
                <div class="mode-card" onclick="selectGameMode('pvp')">
                    <h2>👥 PVP</h2>
                    <p>Đấu với bạn bè<br>2 người chơi<br>Kỹ năng đầy đủ</p>
                </div>
                
                <div class="mode-card" onclick="selectGameMode('ai')">
                    <h2>🤖 VS AI</h2>
                    <p>Đấu với máy<br>4 độ khó<br>AI thông minh</p>
                </div>
                
                <div class="mode-card survival" onclick="selectGameMode('survival')">
                    <h2>⚔️ SINH TỒN</h2>
                    <p>Sống sót càng lâu<br>AI ngày càng mạnh<br>Tính điểm cao</p>
                </div>
                
                <div class="mode-card tournament" onclick="selectGameMode('tournament')">
                    <h2>🏆 GIẢI ĐẤU</h2>
                    <p>8 vòng đấu<br>Đối thủ ngẫu nhiên<br>Vô địch giải</p>
                </div>
                
                <div class="mode-card training" onclick="selectGameMode('training')">
                    <h2>🎯 LUYỆN TẬP</h2>
                    <p>Không giới hạn HP<br>Test kỹ năng<br>Không AI phản công</p>
                </div>
                
                <div class="mode-card timeattack" onclick="selectGameMode('timeattack')">
                    <h2>⏱️ THỜI GIAN</h2>
                    <p>60 giây<br>Gây damage nhiều nhất<br>Chạy đua thời gian</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- PAUSE MENU -->
    <div class="pause-menu" id="pauseMenu">
        <div class="pause-content">
            <h1>⏸️ TẠM DỪNG</h1>
            <button onclick="resumeGame()">▶️ TIẾP TỤC</button>
            <button onclick="backToMenu()">🏠 MENU CHÍNH</button>
            <button onclick="restartGame(); resumeGame();">🔄 CHƠI LẠI</button>
        </div>
    </div>

    <div id="gameContainer">
        <!-- SOUND TOGGLE -->
        <div class="sound-toggle" id="soundToggle" onclick="toggleSound()">🔊</div>
        
        <!-- MAP SELECTOR -->
        <div class="map-selector" id="mapSelector"></div>
        
        <!-- TIMER DISPLAY -->
        <div class="timer-display" id="timerDisplay">
            <h2 id="timerText">60</h2>
        </div>
        
        <!-- GAME INFO -->
        <div class="game-info" id="gameInfo"></div>
        
        <!-- HUD -->
        <div class="hud">
            <div class="player-stats player1-stats">
                <div class="player-name" id="p1Name">🥊 PLAYER 1</div>
                <div class="hp-bar">
                    <div class="hp-fill" id="p1Hp" style="width: 100%"></div>
                </div>
                <div class="stat-text" id="p1HpText">HP: 100/100</div>
                
                <div class="energy-bar">
                    <div class="energy-fill" id="p1Energy" style="width: 100%"></div>
                </div>
                <div class="stat-text" id="p1EnergyText">Energy: 100/100</div>
                <div class="combo-display" id="p1Combo"></div>
                
                <div class="skills-container" id="p1Skills"></div>
                
                <div class="controls-help">
                    WASD: Di chuyển | F: Đấm | G: Chặn<br>
                    Skills: 1-4 (Uppercut/Combo/Shield/Dash)
                </div>
            </div>
            
            <div class="player-stats player2-stats">
                <div class="player-name" id="p2Name">AI BOT 🤖</div>
                <div class="hp-bar">
                    <div class="hp-fill" id="p2Hp" style="width: 100%"></div>
                </div>
                <div class="stat-text" id="p2HpText">HP: 100/100</div>
                
                <div class="energy-bar">
                    <div class="energy-fill" id="p2Energy" style="width: 100%"></div>
                </div>
                <div class="stat-text" id="p2EnergyText">Energy: 100/100</div>
                <div class="combo-display" id="p2Combo"></div>
                
                <div class="skills-container" id="p2Skills"></div>
                
                <div class="controls-help" id="p2Controls">
                    AI tự động điều khiển
                </div>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="900" height="500"></canvas>
    </div>
    
    <!-- GAME OVER -->
    <div class="game-over" id="gameOver">
        <h1 id="winnerText">PLAYER 1 WINS!</h1>
        <p id="gameStats">🏆 VICTORY 🏆</p>
        <button onclick="backToMenu()">🏠 MENU CHÍNH</button>
        <button onclick="restartGame()">⚔️ CHƠI LẠI</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // GAME STATE
        let gameRunning = false;
        let keys = {};
        let gameMode = null;
        let currentMap = 'classic';
        let aiDifficulty = null;
        let aiEnabled = false;
        
        // SURVIVAL MODE
        let survivalRound = 1;
        let survivalScore = 0;
        let survivalHighScore = localStorage.getItem('survivalHighScore') || 0;
        
        // TOURNAMENT MODE
        let tournamentRound = 1;
        let tournamentWins = 0;
        
        // TIME ATTACK MODE
        let timeAttackTimer = 60;
        let timeAttackDamageDealt = 0;
        let timeAttackHighScore = localStorage.getItem('timeAttackHighScore') || 0;
        
        // SOUND SETTINGS
        let soundEnabled = true;
        
        // PAUSE STATE
        let isPaused = false;
        
        // ==================== MAPS SYSTEM ====================
        const MAPS = {
            classic: {
                name: 'Classic Ring',
                icon: '🥊',
                draw() {
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#1a1a2e');
                    gradient.addColorStop(1, '#16213e');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 5;
                    [100, 200].forEach(y => {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    });
                    
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
                }
            },
            
            neon: {
                name: 'Neon Arena',
                icon: '🌃',
                draw() {
                    ctx.fillStyle = '#0a0a1a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ffff';
                    
                    for (let i = 0; i < canvas.width; i += 40) {
                        ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 500 + i) * 0.2;
                        ctx.beginPath();
                        ctx.moveTo(i, canvas.height - 100);
                        ctx.lineTo(i, canvas.height);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
            },
            
            volcano: {
                name: 'Volcano',
                icon: '🌋',
                draw() {
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#1a0000');
                    gradient.addColorStop(1, '#4a1a00');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#ff4400';
                    ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
                    
                    for (let i = 0; i < 10; i++) {
                        const x = (i * 60 + Date.now() / 20) % canvas.width;
                        const y = canvas.height - 100 - ((Date.now() / 10 + i * 30) % 200);
                        ctx.fillText('🔥', x, y);
                    }
                }
            },
            
            space: {
                name: 'Space',
                icon: '🚀',
                draw() {
                    ctx.fillStyle = '#000033';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#ffffff';
                    for (let i = 0; i < 80; i++) {
                        const x = (i * 73) % canvas.width;
                        const y = (i * 97) % (canvas.height - 100);
                        ctx.fillRect(x, y, 2, 2);
                    }
                    
                    ctx.fillStyle = '#1a1a4a';
                    ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
                }
            },
            
            dojo: {
                name: 'Dojo',
                icon: '🏯',
                draw() {
                    ctx.fillStyle = '#f5e6d3';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#d4a574';
                    ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
                    
                    ctx.strokeStyle = '#d4a574';
                    ctx.lineWidth = 4;
                    for (let i = 0; i < canvas.width; i += 150) {
                        ctx.strokeRect(i + 10, 50, 130, canvas.height - 200);
                    }
                }
            },
            
            cyber: {
                name: 'Cyber City',
                icon: '🌆',
                draw() {
                    ctx.fillStyle = '#0a0a1f';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Buildings
                    ctx.fillStyle = '#1a1a2f';
                    [
                        {x: 0, h: 150}, {x: 100, h: 200}, {x: 200, h: 120},
                        {x: 300, h: 180}, {x: 500, h: 220}, {x: 700, h: 160}
                    ].forEach(b => {
                        ctx.fillRect(b.x, canvas.height - 100 - b.h, 90, b.h);
                    });
                    
                    ctx.fillStyle = '#1f1f3f';
                    ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
                }
            }
        };
        
        // Create map buttons
        function initMapSelector() {
            const selector = document.getElementById('mapSelector');
            selector.innerHTML = '';
            Object.keys(MAPS).forEach(mapId => {
                const btn = document.createElement('button');
                btn.className = 'map-btn';
                btn.textContent = MAPS[mapId].icon;
                btn.title = MAPS[mapId].name;
                btn.onclick = () => {
                    currentMap = mapId;
                    document.querySelectorAll('.map-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                };
                if (mapId === 'classic') btn.classList.add('active');
                selector.appendChild(btn);
            });
        }
        
        // ==================== SKILLS SYSTEM ====================
        const SKILLS = {
            uppercut: {
                name: 'Uppercut',
                icon: '⬆️',
                key: '1',
                damage: 20,
                energyCost: 30,
                cooldown: 180,
                execute(attacker, defender) {
                    if (defender) {
                        defender.velocityY = -18;
                        defender.stunned = true;
                        defender.stunnedTime = 45;
                        defender.takeDamage(this.damage, attacker);
                        
                        // Visual effect
                        ctx.save();
                        ctx.strokeStyle = '#ff9900';
                        ctx.lineWidth = 5;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ff9900';
                        ctx.beginPath();
                        ctx.arc(attacker.x + 20, attacker.y + 40, 30, Math.PI, 0);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            },
            
            comboRush: {
                name: 'Combo Rush',
                icon: '💥',
                key: '2',
                damage: 8,
                energyCost: 40,
                cooldown: 200,
                execute(attacker, defender) {
                    let hits = 0;
                    const interval = setInterval(() => {
                        if (hits++ >= 5) {
                            clearInterval(interval);
                            return;
                        }
                        if (defender && !defender.isBlocking) {
                            defender.takeDamage(this.damage, attacker);
                        }
                    }, 100);
                }
            },
            
            counterShield: {
                name: 'Counter Shield',
                icon: '🛡️',
                key: '3',
                energyCost: 35,
                cooldown: 240,
                execute(attacker) {
                    attacker.counterShieldActive = true;
                    attacker.counterShieldTime = 90;
                }
            },
            
            lightningDash: {
                name: 'Lightning Dash',
                icon: '⚡',
                key: '4',
                damage: 15,
                energyCost: 25,
                cooldown: 150,
                execute(attacker, defender) {
                    const direction = attacker.facingRight ? 1 : -1;
                    attacker.x = Math.max(0, Math.min(attacker.x + (150 * direction), 900 - attacker.width));
                    
                    if (defender) {
                        const distance = Math.abs(attacker.x - defender.x);
                        if (distance < 60) {
                            defender.takeDamage(this.damage, attacker);
                            defender.velocityX = direction * 8;
                        }
                    }
                    
                    // Visual
                    ctx.save();
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ffff00';
                    ctx.beginPath();
                    ctx.moveTo(attacker.x, attacker.y + 40);
                    ctx.lineTo(attacker.x - (direction * 100), attacker.y + 40);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        };
        
        // ==================== FIGHTER CLASS ====================
        class Fighter {
            constructor(x, color, controls, name, isAI = false) {
                this.x = x;
                this.y = canvas.height - 100;
                this.width = 40;
                this.height = 80;
                this.color = color;
                this.hp = 100;
                this.maxHp = 100;
                this.energy = 100;
                this.maxEnergy = 100;
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = 5;
                this.jumpPower = 15;
                this.onGround = true;
                this.facingRight = name === 'p2';
                this.controls = controls;
                this.name = name;
                this.isAI = isAI;
                
                this.isPunching = false;
                this.isBlocking = false;
                this.punchCooldown = 0;
                this.stunned = false;
                this.stunnedTime = 0;
                this.combo = 0;
                this.comboTimer = 0;
                this.hitFlash = 0;
                
                this.skillCooldowns = {};
                this.counterShieldActive = false;
                this.counterShieldTime = 0;
                
                Object.keys(SKILLS).forEach(key => {
                    this.skillCooldowns[key] = 0;
                });
            }
            
            update() {
                // Energy regeneration
                if (this.energy < this.maxEnergy) {
                    this.energy += gameMode === 'training' ? 0.3 : 0.15;
                }
                
                // Update cooldowns
                Object.keys(this.skillCooldowns).forEach(key => {
                    if (this.skillCooldowns[key] > 0) this.skillCooldowns[key]--;
                });
                
                if (this.counterShieldTime > 0) this.counterShieldTime--;
                else this.counterShieldActive = false;
                
                if (this.comboTimer > 0) {
                    this.comboTimer--;
                    if (this.comboTimer === 0) this.combo = 0;
                }
                
                if (this.stunned) {
                    this.stunnedTime--;
                    if (this.stunnedTime <= 0) this.stunned = false;
                    return;
                }
                
                // Movement
                if (keys[this.controls.left]) {
                    this.velocityX = -this.speed;
                    this.facingRight = false;
                }
                if (keys[this.controls.right]) {
                    this.velocityX = this.speed;
                    this.facingRight = true;
                }
                if (keys[this.controls.up] && this.onGround) {
                    this.velocityY = -this.jumpPower;
                    this.onGround = false;
                }
                
                // Combat
                if (keys[this.controls.punch] && this.punchCooldown === 0) {
                    this.punch();
                }
                
                this.isBlocking = keys[this.controls.block] && this.onGround;
                
                // Skills (only for human players)
                if (!this.isAI) {
                    Object.keys(SKILLS).forEach(skillName => {
                        const skill = SKILLS[skillName];
                        if (keys[skill.key] && this.canUseSkill(skillName)) {
                            this.useSkill(skillName);
                        }
                    });
                }
                
                // Physics
                this.velocityY += 0.8;
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.velocityX *= 0.8;
                
                // Boundaries
                this.x = Math.max(0, Math.min(this.x, canvas.width - this.width));
                if (this.y > canvas.height - 100) {
                    this.y = canvas.height - 100;
                    this.velocityY = 0;
                    this.onGround = true;
                }
                
                if (this.punchCooldown > 0) this.punchCooldown--;
                if (this.hitFlash > 0) this.hitFlash--;
            }
            
            punch() {
                this.isPunching = true;
                this.punchCooldown = 20;
                setTimeout(() => this.isPunching = false, 200);
            }
            
            canUseSkill(skillName) {
                const skill = SKILLS[skillName];
                return skill && 
                       this.skillCooldowns[skillName] === 0 && 
                       this.energy >= skill.energyCost;
            }
            
            useSkill(skillName) {
                if (!this.canUseSkill(skillName)) return false;
                
                const skill = SKILLS[skillName];
                this.energy -= skill.energyCost;
                this.skillCooldowns[skillName] = skill.cooldown;
                
                const opponent = this === player1 ? player2 : player1;
                skill.execute(this, opponent);
                
                return true;
            }
            
            takeDamage(amount, attacker) {
                if (gameMode === 'training' && this.name === 'p1') {
                    // Training mode: player doesn't take damage
                    return;
                }
                
                // Track damage for time attack mode
                if (gameMode === 'timeattack' && attacker.name === 'p1') {
                    timeAttackDamageDealt += amount;
                }
                
                if (this.isBlocking) {
                    amount *= 0.3;
                } else if (this.counterShieldActive) {
                    attacker.takeDamage(amount * 0.5, this);
                    return;
                } else {
                    attacker.combo++;
                    attacker.comboTimer = 120;
                    
                    if (attacker.combo >= 3) {
                        amount *= 1.5;
                        this.stunned = true;
                        this.stunnedTime = 30;
                    }
                }
                
                this.hp -= amount;
                this.hitFlash = 10;
                
                if (this.hp <= 0) {
                    this.hp = 0;
                    if (gameMode !== 'timeattack') {
                        endGame(attacker.name);
                    }
                }
                
                updateStats();
            }
            
            draw() {
                ctx.save();
                
                // Hit flash
                if (this.hitFlash > 0) {
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
                    ctx.globalAlpha = 1;
                }
                
                // Body
                ctx.fillStyle = this.stunned ? '#888' : this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Head
                ctx.fillStyle = '#ffdbac';
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y - 10, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                if (this.stunned) {
                    ctx.fillStyle = 'black';
                    ctx.font = '12px Arial';
                    ctx.fillText('X X', this.x + 5, this.y - 8);
                } else {
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.x + 13, this.y - 10, 2, 0, Math.PI * 2);
                    ctx.arc(this.x + 23, this.y - 10, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Gloves
                ctx.fillStyle = '#ff0000';
                if (this.isPunching) {
                    const punchOffset = this.facingRight ? 50 : -50;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2 + punchOffset, this.y + 20, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Punch effect
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2 + punchOffset, this.y + 20, 20, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x + (this.facingRight ? this.width - 5 : 5), this.y + 30, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Block shield
                if (this.isBlocking) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, 50, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Counter shield
                if (this.counterShieldActive) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ffff';
                    const time = Date.now() / 100;
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 * i / 6) + time;
                        const x1 = this.x + this.width/2 + Math.cos(angle) * 45;
                        const y1 = this.y + this.height/2 + Math.sin(angle) * 45;
                        const x2 = this.x + this.width/2 + Math.cos(angle + Math.PI/3) * 45;
                        const y2 = this.y + this.height/2 + Math.sin(angle + Math.PI/3) * 45;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
            }
        }
        
        // Initialize players
        let player1, player2;
        
        function initPlayers() {
            player1 = new Fighter(100, '#4a90e2', {
                left: 'a', right: 'd', up: 'w', punch: 'f', block: 'g'
            }, 'p1', false);
            
            player2 = new Fighter(750, '#e74c3c', {
                left: 'ArrowLeft', right: 'ArrowRight', up: 'ArrowUp', 
                punch: 'End', block: 'PageDown'
            }, 'p2', aiEnabled);
        }
        
        // ==================== GAME MODE SELECTION ====================
        function selectGameMode(mode) {
            gameMode = mode;
            document.getElementById('gameModeSelector').style.display = 'none';
            
            switch(mode) {
                case 'pvp':
                    aiEnabled = false;
                    document.getElementById('p2Name').textContent = 'PLAYER 2 🥊';
                    document.getElementById('p2Controls').innerHTML = 
                        '↑←↓→: Di chuyển | End: Đấm | PgDn: Chặn<br>Skills: Số 1-4 (như Player 1)';
                    break;
                    
                case 'ai':
                    selectAIDifficulty();
                    return;
                    
                case 'survival':
                    aiEnabled = true;
                    aiDifficulty = 'easy';
                    survivalRound = 1;
                    survivalScore = 0;
                    updateGameInfo();
                    document.getElementById('p2Name').textContent = `🤖 AI - ROUND ${survivalRound}`;
                    break;
                    
                case 'tournament':
                    aiEnabled = true;
                    aiDifficulty = ['easy', 'medium', 'hard'][Math.floor(Math.random() * 3)];
                    tournamentRound = 1;
                    tournamentWins = 0;
                    updateGameInfo();
                    document.getElementById('p2Name').textContent = `🏆 ĐỐI THỦ ${tournamentRound}/8`;
                    break;
                    
                case 'training':
                    aiEnabled = false;
                    document.getElementById('p2Name').textContent = '🎯 TRAINING BOT';
                    document.getElementById('p2Controls').textContent = 'Không phản công - Luyện kỹ năng thoải mái';
                    break;
                    
                case 'timeattack':
                    aiEnabled = true;
                    aiDifficulty = 'medium';
                    timeAttackTimer = 60;
                    timeAttackDamageDealt = 0;
                    updateGameInfo();
                    document.getElementById('p2Name').textContent = '⏱️ AI TARGET';
                    document.getElementById('timerDisplay').style.display = 'block';
                    break;
            }
            
            initPlayers();
            initSkillButtons();
            startGame();
        }
        
        function selectAIDifficulty() {
            const difficulties = ['easy', 'medium', 'hard', 'super'];
            const icons = ['😊', '😐', '😈', '💀'];
            const names = ['DỄ', 'TRUNG BÌNH', 'KHÓ', 'SIÊU AI'];
            
            const selector = document.getElementById('gameModeSelector');
            selector.innerHTML = `
                <div class="mode-content">
                    <h1>🤖 CHỌN ĐỘ KHÓ AI 🤖</h1>
                    <div class="mode-grid">
                        ${difficulties.map((diff, i) => `
                            <div class="mode-card" onclick="setAIDifficulty('${diff}')">
                                <h2>${icons[i]} ${names[i]}</h2>
                                <p>${diff === 'super' ? 'Không thể đánh bại!' : 'AI mức ' + names[i].toLowerCase()}</p>
                            </div>
                        `).join('')}
                    </div>
                    <button onclick="backToModeSelect()" style="margin-top: 20px; padding: 15px 30px; font-size: 18px; background: #95a5a6; border: none; border-radius: 8px; cursor: pointer; color: white;">
                        ← Quay lại
                    </button>
                </div>
            `;
        }
        
        function setAIDifficulty(diff) {
            aiEnabled = true;
            aiDifficulty = diff;
            document.getElementById('gameModeSelector').style.display = 'none';
            document.getElementById('p2Name').textContent = `🤖 AI ${diff.toUpperCase()}`;
            document.getElementById('p2Controls').textContent = 'AI tự động điều khiển';
            
            initPlayers();
            initSkillButtons();
            startGame();
        }
        
        function backToModeSelect() {
            location.reload();
        }
        
        // ==================== SKILL BUTTONS ====================
        function initSkillButtons() {
            ['p1', 'p2'].forEach(p => {
                const container = document.getElementById(`${p}Skills`);
                container.innerHTML = '';
                
                Object.values(SKILLS).forEach(skill => {
                    const btn = document.createElement('div');
                    btn.className = 'skill-btn';
                    btn.innerHTML = skill.icon;
                    btn.title = `${skill.name} (${skill.key})`;
                    container.appendChild(btn);
                });
            });
        }
        
        function updateSkillButtons() {
            [player1, player2].forEach((player, i) => {
                const prefix = i === 0 ? 'p1' : 'p2';
                const container = document.getElementById(`${prefix}Skills`);
                const buttons = container.querySelectorAll('.skill-btn');
                
                Object.keys(SKILLS).forEach((skillName, j) => {
                    const skill = SKILLS[skillName];
                    const btn = buttons[j];
                    const cd = player.skillCooldowns[skillName];
                    
                    if (cd > 0 || player.energy < skill.energyCost) {
                        btn.classList.add('cooldown');
                    } else {
                        btn.classList.remove('cooldown');
                    }
                });
            });
        }
        
        // ==================== GAME INFO ====================
        function updateGameInfo() {
            const info = document.getElementById('gameInfo');
            info.style.display = 'block';
            
            if (gameMode === 'survival') {
                info.innerHTML = `
                    ⚔️ ROUND ${survivalRound} | 
                    📊 SCORE: ${survivalScore} | 
                    🏆 HIGH: ${survivalHighScore}
                `;
            } else if (gameMode === 'tournament') {
                info.innerHTML = `
                    🏆 GIẢI ĐẤU | 
                    Vòng ${tournamentRound}/8 | 
                    Thắng: ${tournamentWins}
                `;
            } else if (gameMode === 'timeattack') {
                info.innerHTML = `
                    ⏱️ DAMAGE: ${Math.floor(timeAttackDamageDealt)} | 
                    🏆 HIGH: ${timeAttackHighScore}
                `;
            } else {
                info.style.display = 'none';
            }
        }
        
        // ==================== SOUND & PAUSE ====================
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundToggle').textContent = soundEnabled ? '🔊' : '🔇';
        }
        
        function pauseGame() {
            if (gameMode && gameRunning) {
                isPaused = true;
                gameRunning = false;
                document.getElementById('pauseMenu').style.display = 'flex';
            }
        }
        
        function resumeGame() {
            isPaused = false;
            gameRunning = true;
            document.getElementById('pauseMenu').style.display = 'none';
            gameLoop();
        }
        
        // ==================== GAME CONTROL ====================
        function startGame() {
            gameRunning = true;
            updateStats();
            updateGameInfo();
            gameLoop();
        }
        
        function endGame(winner) {
            gameRunning = false;
            
            const gameOverDiv = document.getElementById('gameOver');
            const winnerText = document.getElementById('winnerText');
            const gameStats = document.getElementById('gameStats');
            
            // Handle different game modes
            if (gameMode === 'survival') {
                if (winner === 'p1') {
                    // Player won, next round
                    survivalScore += survivalRound * 100;
                    survivalRound++;
                    
                    if (survivalScore > survivalHighScore) {
                        survivalHighScore = survivalScore;
                        localStorage.setItem('survivalHighScore', survivalHighScore);
                    }
                    
                    winnerText.textContent = `🎉 ROUND ${survivalRound - 1} HOÀN THÀNH!`;
                    gameStats.innerHTML = `
                        Score: ${survivalScore}<br>
                        Next: Round ${survivalRound} - AI sẽ mạnh hơn!
                    `;
                } else {
                    // Player lost
                    winnerText.textContent = '💀 GAME OVER';
                    gameStats.innerHTML = `
                        Final Score: ${survivalScore}<br>
                        Survived ${survivalRound - 1} rounds<br>
                        ${survivalScore > survivalHighScore ? '🏆 NEW HIGH SCORE!' : 'High Score: ' + survivalHighScore}
                    `;
                }
            } else if (gameMode === 'tournament') {
                if (winner === 'p1') {
                    tournamentWins++;
                    tournamentRound++;
                    
                    if (tournamentRound > 8) {
                        winnerText.textContent = '👑 VÔ ĐỊCH GIẢI ĐẤU!';
                        gameStats.innerHTML = `🏆 BẠN ĐÃ THẮNG TẤT CẢ 8 TRẬN! 🏆`;
                    } else {
                        winnerText.textContent = `✅ THẮNG VÒNG ${tournamentRound - 1}/8`;
                        gameStats.innerHTML = `Next: Vòng ${tournamentRound}`;
                    }
                } else {
                    winnerText.textContent = '❌ BỊ LOẠI';
                    gameStats.innerHTML = `
                        Thắng ${tournamentWins} vòng<br>
                        Thua ở vòng ${tournamentRound}
                    `;
                }
            } else if (gameMode === 'timeattack') {
                const finalDamage = Math.floor(timeAttackDamageDealt);
                const isHighScore = finalDamage > timeAttackHighScore;
                
                if (isHighScore) {
                    timeAttackHighScore = finalDamage;
                    localStorage.setItem('timeAttackHighScore', timeAttackHighScore);
                }
                
                winnerText.textContent = '⏱️ HẾT GIỜ!';
                winnerText.className = '';
                gameStats.innerHTML = `
                    Total Damage: ${finalDamage}<br>
                    ${isHighScore ? '🏆 NEW HIGH SCORE! 🏆' : 'High Score: ' + timeAttackHighScore}<br>
                    ${finalDamage > 500 ? '💪 XUẤT SẮC!' : finalDamage > 300 ? '👍 TỐT!' : '📈 CỐ GẮNG HơN!'}
                `;
            } else {
                // PVP, AI, Training
                if (winner === 'p1') {
                    winnerText.textContent = '🥊 PLAYER 1 WINS! 🥊';
                    winnerText.className = 'winner1';
                } else {
                    winnerText.textContent = aiEnabled ? '🤖 AI WINS! 🤖' : '🥊 PLAYER 2 WINS! 🥊';
                    winnerText.className = 'winner2';
                }
                gameStats.textContent = '🏆 VICTORY 🏆';
            }
            
            gameOverDiv.style.display = 'block';
        }
        
        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            
            // Adjust difficulty for survival mode
            if (gameMode === 'survival') {
                if (survivalRound <= 3) aiDifficulty = 'easy';
                else if (survivalRound <= 6) aiDifficulty = 'medium';
                else if (survivalRound <= 10) aiDifficulty = 'hard';
                else aiDifficulty = 'super';
                
                document.getElementById('p2Name').textContent = `🤖 AI - ROUND ${survivalRound}`;
            } else if (gameMode === 'tournament' && tournamentRound <= 8) {
                aiDifficulty = ['easy', 'medium', 'hard'][Math.floor(Math.random() * 3)];
                document.getElementById('p2Name').textContent = `🏆 ĐỐI THỦ ${tournamentRound}/8`;
            }
            
            initPlayers();
            startGame();
        }
        
        function backToMenu() {
            location.reload();
        }
        
        // ==================== UPDATE & DRAW ====================
        function updateStats() {
            [player1, player2].forEach((player, i) => {
                const prefix = i === 0 ? 'p1' : 'p2';
                const hpPercent = (player.hp / player.maxHp) * 100;
                const energyPercent = (player.energy / player.maxEnergy) * 100;
                
                const hpBar = document.getElementById(`${prefix}Hp`);
                hpBar.style.width = hpPercent + '%';
                hpBar.className = 'hp-fill';
                if (hpPercent < 30) hpBar.classList.add('critical');
                else if (hpPercent < 60) hpBar.classList.add('low');
                
                document.getElementById(`${prefix}Energy`).style.width = energyPercent + '%';
                document.getElementById(`${prefix}HpText`).textContent = 
                    `HP: ${Math.floor(player.hp)}/${player.maxHp}`;
                document.getElementById(`${prefix}EnergyText`).textContent = 
                    `Energy: ${Math.floor(player.energy)}/${player.maxEnergy}`;
                
                const combo = document.getElementById(`${prefix}Combo`);
                combo.textContent = player.combo >= 2 ? `🔥 COMBO x${player.combo}` : '';
            });
            
            updateSkillButtons();
        }
        
        function checkPunchCollision(attacker, defender) {
            if (!attacker.isPunching || attacker.punchCooldown > 10) return;
            
            const distance = Math.abs(attacker.x - defender.x);
            const yDistance = Math.abs(attacker.y - defender.y);
            
            if (distance < 60 && yDistance < 50) {
                const damage = gameMode === 'training' && attacker.name === 'p2' ? 0 : 8;
                if (damage > 0) {
                    defender.takeDamage(damage, attacker);
                }
            }
        }
        
        // Simple AI (for non-AI modes, player 2 is dummy)
        let aiDecisionTimer = 0;
        let aiAction = null;
        
        function updateSimpleAI() {
            if (!aiEnabled || gameMode === 'training') return;
            
            const ai = player2;
            const target = player1;
            
            // Reset controls
            ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'PageDown'].forEach(k => keys[k] = false);
            
            const distance = Math.abs(ai.x - target.x);
            const isTargetLeft = target.x < ai.x;
            
            aiDecisionTimer--;
            
            if (aiDecisionTimer <= 0) {
                const difficultyMap = {
                    'easy': { reaction: 30, accuracy: 0.5, aggression: 0.3 },
                    'medium': { reaction: 20, accuracy: 0.7, aggression: 0.5 },
                    'hard': { reaction: 10, accuracy: 0.9, aggression: 0.7 },
                    'super': { reaction: 5, accuracy: 0.95, aggression: 0.9 }
                };
                
                const config = difficultyMap[aiDifficulty] || difficultyMap['medium'];
                aiDecisionTimer = config.reaction;
                
                // Decision
                if (target.isPunching && distance < 100 && Math.random() < 0.6) {
                    aiAction = 'block';
                } else if (distance > 150) {
                    aiAction = 'approach';
                } else if (distance < 100 && Math.random() < config.aggression) {
                    aiAction = 'punch';
                } else if (distance < 50 && ai.hp < 40) {
                    aiAction = 'retreat';
                } else {
                    aiAction = 'idle';
                }
            }
            
            // Execute
            switch(aiAction) {
                case 'approach':
                    keys[isTargetLeft ? 'ArrowLeft' : 'ArrowRight'] = true;
                    break;
                case 'retreat':
                    keys[isTargetLeft ? 'ArrowRight' : 'ArrowLeft'] = true;
                    break;
                case 'punch':
                    keys['End'] = true;
                    break;
                case 'block':
                    keys['PageDown'] = true;
                    break;
            }
            
            // AI uses skills randomly
            if (aiDifficulty === 'hard' || aiDifficulty === 'super') {
                Object.keys(SKILLS).forEach(skillName => {
                    if (Math.random() < 0.01 && ai.canUseSkill(skillName)) {
                        ai.useSkill(skillName);
                    }
                });
            }
        }
        
        function gameLoop() {
            if (!gameRunning) return;
            
            // Draw map
            MAPS[currentMap].draw();
            
            // Update timer for time attack mode
            if (gameMode === 'timeattack') {
                timeAttackTimer -= 1/60;
                const timerDisplay = document.getElementById('timerDisplay');
                const timerText = document.getElementById('timerText');
                
                if (timeAttackTimer <= 0) {
                    timeAttackTimer = 0;
                    endGame('timeup');
                } else {
                    timerText.textContent = Math.ceil(timeAttackTimer);
                    
                    // Warning when time is low
                    if (timeAttackTimer <= 10) {
                        timerDisplay.classList.add('warning');
                    } else {
                        timerDisplay.classList.remove('warning');
                    }
                }
                
                updateGameInfo();
            }
            
            // Update AI
            updateSimpleAI();
            
            // Update players
            player1.update();
            player2.update();
            
            // Auto-heal in time attack mode
            if (gameMode === 'timeattack') {
                if (player1.hp < player1.maxHp) player1.hp += 0.1;
                if (player2.hp < player2.maxHp) player2.hp += 0.2;
            }
            
            // Check collisions
            checkPunchCollision(player1, player2);
            checkPunchCollision(player2, player1);
            
            // Draw players
            player1.draw();
            player2.draw();
            
            // Update HUD
            updateStats();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ==================== INPUT ====================
        document.addEventListener('keydown', (e) => {
            // Pause with ESC
            if (e.key === 'Escape') {
                if (isPaused) resumeGame();
                else pauseGame();
                return;
            }
            
            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;
        });
        
        // ==================== INIT ====================
        initMapSelector();
    </script>
</body>
</html>
